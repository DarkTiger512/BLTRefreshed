using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using TaleWorlds.Library;
using static System.String;
using FieldAttributes = dnlib.DotNet.FieldAttributes;
using MethodAttributes = dnlib.DotNet.MethodAttributes;
using TypeAttributes = dnlib.DotNet.TypeAttributes;

namespace BannerlordTwitch.Util
{
    public static class Publicize
    {
        private static readonly string[] AssembliesToProcess = {
            "SandBox.GauntletUI.AutoGenerated.dll",
            "SandBox.GauntletUI.dll",
            "SandBox.View.dll",
            "SandBox.ViewModelCollection.dll",
            "StoryMode.dll",
            "StoryMode.GauntletUI.dll",
            "StoryMode.View.dll",
            "StoryMode.ViewModelCollection.dll",
            "TaleWorlds.MountAndBlade.CustomBattle.dll",
            "TaleWorlds.MountAndBlade.GauntletUI.AutoGenerated.dll",
            "TaleWorlds.MountAndBlade.GauntletUI.dll",
            "TaleWorlds.MountAndBlade.Platform.PC.dll",
            "TaleWorlds.MountAndBlade.View.dll",
            "SandBox.dll",
            "TaleWorlds.PlatformService.GOG.dll",
            "TaleWorlds.PlatformService.Steam.dll",
            "TaleWorlds.PlayerServices.dll",
            "TaleWorlds.PSAI.dll",
            "TaleWorlds.SaveSystem.dll",
            "TaleWorlds.Starter.DotNetCore.dll",
            "TaleWorlds.Starter.Library.dll",
            "TaleWorlds.TwoDimension.dll",
            "TaleWorlds.TwoDimension.Standalone.dll",
            "TaleWorlds.AchievementSystem.dll",
            "TaleWorlds.BattlEye.Client.dll",
            "TaleWorlds.CampaignSystem.dll",
            "TaleWorlds.CampaignSystem.ViewModelCollection.dll",
            "TaleWorlds.Core.dll",
            "TaleWorlds.Core.ViewModelCollection.dll",
            "TaleWorlds.Diamond.AccessProvider.Epic.dll",
            "TaleWorlds.Diamond.AccessProvider.GDK.dll",
            "TaleWorlds.Diamond.AccessProvider.GOG.dll",
            "TaleWorlds.Diamond.AccessProvider.Steam.dll",
            "TaleWorlds.Diamond.AccessProvider.Test.dll",
            "TaleWorlds.Diamond.ChatSystem.Library.dll",
            "TaleWorlds.Diamond.dll",
            "TaleWorlds.DotNet.AutoGenerated.dll",
            "TaleWorlds.DotNet.dll",
            "TaleWorlds.Engine.AutoGenerated.dll",
            "TaleWorlds.Engine.dll",
            "TaleWorlds.Engine.GauntletUI.dll",
            "TaleWorlds.GauntletUI.Data.dll",
            "TaleWorlds.GauntletUI.dll",
            "TaleWorlds.GauntletUI.ExtraWidgets.dll",
            "TaleWorlds.GauntletUI.PrefabSystem.dll",
            "TaleWorlds.GauntletUI.TooltipExtensions.dll",
            "TaleWorlds.InputSystem.dll",
            "TaleWorlds.Library.dll",
            "TaleWorlds.LinQuick.dll",
            "TaleWorlds.Localization.dll",
            "TaleWorlds.ModuleManager.dll",
            "TaleWorlds.MountAndBlade.AutoGenerated.dll",
            "TaleWorlds.MountAndBlade.Diamond.dll",
            "TaleWorlds.MountAndBlade.dll",
            "TaleWorlds.MountAndBlade.GauntletUI.Widgets.dll",
            "TaleWorlds.MountAndBlade.Helpers.dll",
            "TaleWorlds.MountAndBlade.Launcher.Steam.dll",
            "TaleWorlds.MountAndBlade.ViewModelCollection.dll",
            "TaleWorlds.Native.dll",
            "TaleWorlds.NavigationSystem.dll",
            "TaleWorlds.Network.dll",
            "TaleWorlds.ObjectSystem.dll",
            "TaleWorlds.PlatformService.dll",
            "TaleWorlds.PlatformService.Epic.dll",
        };

        [CommandLineFunctionality.CommandLineArgumentFunction("run", "pub")]
        public static string Run(List<string> _)
        {
            var assemblies = AppDomain.CurrentDomain.GetAssemblies();

            foreach (var assembly in assemblies)
            {
                if (!assembly.IsDynamic && AssembliesToProcess.Any(a => string.Equals(a, Path.GetFileName(assembly.Location), StringComparison.InvariantCultureIgnoreCase)))
                {
                    ProcessAssembly(assembly);
                }
            }

            return Empty;
        }

        private static void ProcessAssembly(Assembly assembly)
        {
            var assemblyPath = assembly.Location;
            var filename = assembly.GetName().Name;
            var outputPath = Path.Combine(Path.GetDirectoryName(assemblyPath), "publicized_assemblies");
            var outputSuffix = "_publicized";

            Directory.CreateDirectory(outputPath);

            string lastHash = null;
            var curHash = ComputeHash(assemblyPath);

            var hashPath = Path.Combine(outputPath, $"{filename}{outputSuffix}.hash");

            if (File.Exists(hashPath))
            {
                lastHash = File.ReadAllText(hashPath);
            }

            if (curHash == lastHash)
            {
                return;
            }
            
            RewriteAssembly(assemblyPath).Write($"{Path.Combine(outputPath, filename)}{outputSuffix}.dll");
            File.WriteAllText(hashPath, curHash);
        }

        private static string ComputeHash(string assemblyPath)
        {
            var res = new StringBuilder();
            using (var hash = SHA1.Create())
            {
                using (var file = File.Open(assemblyPath, FileMode.Open, FileAccess.Read, FileShare.Read))
                {
                    hash.ComputeHash(file);
                    file.Close();
                }

                foreach (var b in hash.Hash)
                {
                    res.Append(b.ToString("X2"));
                }
            }

            return res.ToString();
        }

        private static ModuleDef RewriteAssembly(string assemblyPath)
        {
            ModuleDef assembly = ModuleDefMD.Load(assemblyPath);
            foreach (TypeDef type in assembly.GetTypes())
            {
                type.Attributes &= ~TypeAttributes.VisibilityMask;

                if (type.IsNested)
                {
                    type.Attributes |= TypeAttributes.NestedPublic;
                }
                else
                {
                    type.Attributes |= TypeAttributes.Public;
                }

                foreach (MethodDef method in type.Methods)
                {
                    method.Attributes &= ~MethodAttributes.MemberAccessMask;
                    method.Attributes |= MethodAttributes.Public;
                }

                var eventNames = new List<string>();
                foreach (EventDef ev in type.Events)
                {
                    eventNames.Add(ev.Name);
                }

                foreach (FieldDef field in type.Fields)
                {
                    if (!eventNames.Contains(field.Name))
                    {
                        field.Attributes &= ~FieldAttributes.FieldAccessMask;
                        field.Attributes |= FieldAttributes.Public;
                    }
                }
            }
            return assembly;
        }
    }
}